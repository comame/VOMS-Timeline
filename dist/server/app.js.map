{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/server/dotenv.ts","webpack:///./src/config/channels.ts","webpack:///external \"path\"","webpack:///./src/server/fetch.ts","webpack:///./src/server/app.ts","webpack:///external \"express\"","webpack:///external \"mongodb\"","webpack:///./src/server/websubExpressHandler.ts","webpack:///external \"crypto\"","webpack:///external \"fast-xml-parser\"","webpack:///external \"fs\"","webpack:///./src/server/fetchVideo.ts","webpack:///./src/API/YouTubeApiOptions/VideosAPIOptions.ts","webpack:///external \"https\"","webpack:///./src/config/apiEndpoints.ts","webpack:///./src/util/urlQueryBuilder.ts","webpack:///./src/API/YouTubeApiOptions/SearchAPIOptions.ts","webpack:///./src/server/cache.ts","webpack:///./src/util/videoTime.ts","webpack:///./src/util/DateString.ts","webpack:///./src/server/requestSubscription.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","dotenv","fromEntries","readFileSync","resolve","__dirname","encoding","split","map","line","channels","require","async","url","option","Promise","reject","req","request","res","responseText","on","chunk","TextDecoder","decode","headers","keys","Array","isArray","join","Response","statusCode","err","body","write","end","status","this","ok","json","JSON","parse","text","app","db","use","next","bodyText","toString","static","query","originalUrl","it","verifySubscription","Number","parseInt","send","sendStatus","post","videoId","obtainVideoIdFromNotification","header","videos","fetchVideo","cacheResponse","isYouTubeApiSearching","isYouTubeApiRenewingVideo","lastUpdated","lastFetch","getCached","willSearchVideos","willRefetchOutdatedVideos","Date","now","outdatedUpcomingVideoIds","filter","video","includes","item","snippet","liveBroadcastContent","fetched","id","length","kind","items","toISOString","willUpdate","console","log","videoIds","searchVideos","requestSubscription","updatedUpcomingVideos","MongoClient","connect","useUnifiedTopology","client","process","exit","listen","signature","validate","error","createHmac","WEBSUB_HUB_SECRET","update","digest","slice","updatedVideoId","feed","entry","topic","leaseSeconds","entries","replace","isNaN","options","part","GOOGLE_API_KEY","requestUrl","buildUrlQuery","fetch","isVideoAPIResponse","requestUrls","channelId","maxResults","order","type","search","responses","all","then","every","isSearchAPIResponse","_videoIds","push","arg","youtube","activities","self","encodeURIComponent","metadataCollection","collection","metaUpdate","getTime","updateOne","upsert","videosCollection","_id","time","getVideoTime","limit","cacheMetadata","findOne","find","sort","toArray","liveStreamingDetails","actualEndTime","asDate","scheduledStartTime","publishedAt","dateString","requestPromises","WEBSUB_VERIFY_TOKEN","obj","method"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","import fs from 'fs'\nimport { resolve } from 'path'\n\nexport const dotenv: { [ key: string ]: string } = Object.fromEntries(\n    fs.readFileSync(resolve(__dirname, '../../.env'), {\n        encoding: 'utf8'\n    }).split('\\n').map(line => line.split('='))\n)\n","export const channels = {\n    '天野ピカミィ': 'UCajhBT4nMrg3DLS-bLL2RCg',\n    '緋笠トモシカ': 'UC3vzVK_N_SUVKqbX69L_X4g',\n    '磁富モノエ': 'UCaFhsCKSSS821N-EcWmPkUQ',\n}\n","module.exports = require(\"path\");","import https from 'https'\n\nexport interface HTTPHeaders {\n    [key: string]: string\n}\n\nexport interface FetchOptions {\n    method?: 'GET'|'POST'\n    headers?: HTTPHeaders,\n    body?: string\n}\n\nexport async function fetch(url: string, option?: FetchOptions): Promise<Response> {\n    return new Promise((resolve, reject) => {\n        const req = https.request(url, option ?? {}, (res) => {\n            let responseText = ''\n\n            res.on('data', (chunk: Uint8Array | string) => {\n                if (typeof chunk == 'string') {\n                    responseText += chunk\n                } else {\n                    responseText += new TextDecoder('utf-8').decode(chunk)\n                }\n            })\n\n            res.on('end', () => {\n                const headers = {} as HTTPHeaders\n                for (const key of Object.keys(res.headers)) {\n                    const value: string | string[] | undefined = res.headers[key]\n                    if (typeof value == 'undefined') continue\n                    if (Array.isArray(value)) {\n                        headers[key] = value.join(' ')\n                        continue\n                    }\n                    headers[key] = value\n                }\n\n                resolve(new Response(\n                    headers,\n                    res.statusCode!!,\n                    res.url!!,\n                    responseText\n                ))\n            })\n        })\n\n        req.on('error', (err) => {\n            reject(err)\n        })\n\n        if (option?.body) {\n            req.write(option.body)\n        }\n\n        req.end()\n    })\n}\n\nexport class Response {\n    public ok: boolean\n    public json: () => Promise<{}>\n    public text: () => Promise<string>\n\n    constructor(\n        public headers: HTTPHeaders,\n        public status: number,\n        public url: string,\n        responseText: string\n    ){\n        if (200 <= status && status < 300) {\n            this.ok = true\n        } else {\n            this.ok = false\n        }\n\n        this.json = async () => JSON.parse(responseText)\n        this.text = async () => responseText\n    }\n}\n","import path from 'path'\nimport express, { Response } from 'express'\nimport { MongoClient, Db } from 'mongodb'\nimport { obtainVideoIdFromNotification, verifySubscription } from './websubExpressHandler'\nimport { fetchVideo, searchVideos } from './fetchVideo'\nimport { cacheResponse, getCached } from './cache'\nimport { VideosResponse } from '../API/selfApiOptions/options'\nimport { requestSubscription } from './requestSubscription'\n\nconst app = express()\nlet db: Db\n\n// Parse body as string\n// @ts-ignore: res unused\napp.use((req, res, next) => {\n    let bodyText = ''\n    req.on('data', (chunk: Buffer|string) => {\n        if (typeof chunk == 'string') {\n            bodyText += chunk\n        } else {\n            bodyText += chunk.toString('utf8')\n        }\n    })\n    req.on('end', () => {\n        req.body = bodyText\n        next()\n    })\n})\n\napp.get('**', express.static(path.resolve(__dirname, '../front')))\napp.get('/sub/hook', (req, res) => {\n    const query = Object.fromEntries(req.originalUrl.split('?')[1]?.split('&').map(it => it.split('=')) ?? [])\n    const verified = verifySubscription(query['hub.mode'], query['hub.topic'], Number.parseInt(query['hub.lease_seconds']))\n    if (verified) {\n        res.send(query['hub.challenge'])\n    } else {\n        res.sendStatus(404)\n    }\n})\napp.post('/sub/hook', async (req, res) => {\n    res.send()\n    const videoId = obtainVideoIdFromNotification(req.header('x-hub-signature') ?? '', req.body)\n    if (!videoId) return\n    const videos = await fetchVideo([ videoId ]) ?? []\n    await cacheResponse(db, videos)\n})\n\nlet isYouTubeApiSearching: boolean = false\nlet isYouTubeApiRenewingVideo: boolean = false\n\n// @ts-ignore: req unused\napp.get('/api/videos', async (req, res: Response<VideosResponse>) => {\n    const { videos, lastUpdated, lastFetch } = await getCached(db, 100)\n\n    let willSearchVideos = false\n    let willRefetchOutdatedVideos = false\n\n    if (Date.now() - 24 * 60 * 60 * 1000 / 5 /* 5 times per day */ >= lastFetch && !isYouTubeApiSearching) {\n        willSearchVideos = true\n    }\n\n    const outdatedUpcomingVideoIds = videos.filter(video => (\n        [ 'upcoming', 'live' ].includes(video.item.snippet?.liveBroadcastContent!!) &&\n        Date.now() - 15 * 60 * 1000 /* 15 mins */ >= video.fetched\n    )).map(video => video.item.id)\n    if (outdatedUpcomingVideoIds.length != 0 && !isYouTubeApiRenewingVideo) {\n        willRefetchOutdatedVideos = true\n    }\n\n    res.send({\n        kind: 'voms-timeline.comame.xyz#videosResponse',\n        items: videos.map(it => it.item),\n        lastUpdated: new Date(lastUpdated).toISOString(),\n        willUpdate: willSearchVideos || willRefetchOutdatedVideos || isYouTubeApiRenewingVideo || isYouTubeApiSearching\n    })\n\n    if (willSearchVideos) {\n        isYouTubeApiSearching = true\n        try {\n            console.log('SEARCH VIDEOS')\n            const videoIds = await searchVideos()\n            const videos = await fetchVideo(videoIds) ?? []\n            await cacheResponse(db, videos, Date.now())\n        } finally {\n            isYouTubeApiSearching = false\n        }\n\n        await requestSubscription()\n    }\n\n    if (willRefetchOutdatedVideos) {\n        isYouTubeApiRenewingVideo = true\n        try {\n            console.log('OUTDATED UPCOMINGS', outdatedUpcomingVideoIds)\n            const updatedUpcomingVideos = await fetchVideo(outdatedUpcomingVideoIds) ?? []\n            await cacheResponse(db, updatedUpcomingVideos)\n        } finally {\n            isYouTubeApiRenewingVideo = false\n        }\n    }\n})\n\nMongoClient.connect('mongodb://mongo:27017', { useUnifiedTopology: true }, (err, client) => {\n    if (err) {\n        console.log(err)\n        process.exit(1)\n    }\n    db = client.db('voms-timeline')\n\n    app.listen(80, () => {\n        console.log('LISTEN')\n    })\n})\n","module.exports = require(\"express\");","module.exports = require(\"mongodb\");","import crypto from 'crypto'\nimport { parse as parseXml, validate as validateXml } from 'fast-xml-parser'\nimport { dotenv } from './dotenv'\nimport { channels } from '../config/channels'\n\nexport function obtainVideoIdFromNotification(signature: string, body: string): string|undefined {\n    console.log('Notification')\n\n    if (validateXml(body) !== true) {\n        const error = validateXml(body)\n        console.error('XML syntax error', error)\n        return\n    }\n\n    const hmacDigest = crypto.createHmac('sha1', dotenv.WEBSUB_HUB_SECRET).update(body).digest('hex')\n    const requestedHmacDigest = signature?.slice('sha1='.length)\n\n    if (hmacDigest != requestedHmacDigest) {\n        console.error('Invalid digest')\n        return\n    }\n\n    const subscribeObject = parseXml(body)\n    const updatedVideoId = subscribeObject.feed?.entry?.['yt:videoId'] as string | undefined\n    console.log('Update notification', updatedVideoId)\n    return updatedVideoId\n}\n\nexport function verifySubscription(mode: string, topic: string, leaseSeconds: number): boolean {\n    if (mode == 'subscribe') {\n        const acceptChannelIds = Object.entries(channels).map(it => it[1])\n        const acceptTopics = acceptChannelIds.map(id =>\n            ('https://www.youtube.com/xml/feeds/videos.xml?channel_id=' + id)\n                .replace(/\\?/g, '%3F')\n                .replace(/\\=/g, '%3D')\n        )\n        if (!acceptTopics.includes(topic)) {\n            console.log('Denied WebSub Verification Request (mode: subscribe): invalid topic', topic)\n            return false\n        }\n\n        if (Number.isNaN(leaseSeconds) || leaseSeconds < 432000 / 2) {\n            console.log('Denied WebSub Verification Request (mode: subscribe): invalid leaseSeconds', leaseSeconds)\n            return false\n        }\n\n        console.log('Accepted WebSub Verification Request (mode: subscribe)', topic)\n        return true\n    } else if (mode == 'unsubscribe') {\n        console.log('Denied WebSub Verification Request (mode: unsubscribe)')\n        return false\n    } else if (mode == 'denied') {\n        console.log('Accepted WebSub Verification Request (mode: denied)')\n        return true\n    }\n\n    console.log('Denied invalid WebSub Verification Request')\n    return false\n}\n","module.exports = require(\"crypto\");","module.exports = require(\"fast-xml-parser\");","module.exports = require(\"fs\");","import { VideoAPIOptions, Video, isVideoAPIResponse } from '../API/YouTubeApiOptions/VideosAPIOptions'\nimport { fetch } from './fetch'\nimport { youtube as endpoints } from '../config/apiEndpoints'\nimport { dotenv } from './dotenv'\nimport { buildUrlQuery } from '../util/urlQueryBuilder'\nimport { SearchAPIOptions, isSearchAPIResponse, SearchAPIResponse } from '../API/YouTubeApiOptions/SearchAPIOptions'\nimport { channels } from '../config/channels'\n\nexport async function fetchVideo(videoIds: string[]): Promise<Video[]|undefined> {\n    if (videoIds.length == 0) return []\n\n    const options: VideoAPIOptions = {\n        part: ['id', 'snippet', 'liveStreamingDetails' ],\n        id: videoIds,\n        key: dotenv.GOOGLE_API_KEY\n    }\n    const requestUrl = buildUrlQuery(endpoints.videos, {\n        ...options,\n        part: options.part.join(','),\n        id: videoIds.join(',')\n    })\n\n    const res = await fetch(requestUrl)\n    const json = await res.json()\n\n    if (!isVideoAPIResponse(json)) {\n        throw 'ERROR'\n    }\n    return json.items\n}\n\nexport async function searchVideos(): Promise<string[]> {\n    const channelIds = Object.entries(channels).map(it => it[1])\n    const options: SearchAPIOptions[] = channelIds.map(id => ({\n        part: [ 'id', 'snippet' ],\n        channelId: id,\n        maxResults: 10,\n        order: 'date',\n        type: 'video',\n        key: dotenv.GOOGLE_API_KEY\n    }))\n    const requestUrls = options.map(option => ({\n        ...option,\n        part: option.part.join(',')\n    })).map(option => buildUrlQuery(endpoints.search, option))\n    const responses = await Promise.all(\n        requestUrls.map(url => fetch(url).then(res => res.json()))\n    )\n\n    if (!responses.every(it => isSearchAPIResponse(it))) {\n        console.log(responses)\n        return []\n    }\n\n    const videoIds: string[] = []\n    for (const res of responses as SearchAPIResponse[]) {\n        const _videoIds = res.items.map(it => it.id?.videoId!!)\n        videoIds.push(..._videoIds)\n    }\n\n    return videoIds\n}\n","import { Thumbnails } from './Thumbnails'\nimport { DateString } from '../../util/DateString'\n\nexport interface VideoAPIOptions {\n    part: Array<'id'|'snippet'|'contentDetails'|'liveStreamingDetails'|'player'|'status'>\n    id: string[]\n    maxResults?: number\n    key?: string\n}\n\nexport interface VideoAPIResponse {\n    kind: 'youtube#videoListResponse'\n    etag: string\n    nextPageToken?: string\n    prevPageToken?: string\n    pageInfo: {\n        totalResults: number\n        resultsPerPage: number\n    }\n    items: Video[]\n}\n\nexport interface Video {\n    kind: 'youtube#video'\n    etag: string\n    id: string\n    snippet?: {\n        publishedAt: DateString\n        channelId: string\n        title: string\n        description: string\n        thumbnails: Thumbnails\n        channelTitle: string\n        liveBroadcastContent?: 'live'|'none'|'upcoming'\n    }\n    contentDetails?: {\n        duration: string\n    }\n    player?: {\n        embedHtml: string\n    }\n    liveStreamingDetails?: {\n        actualStartTime?: DateString\n        actualEndTime?: DateString\n        scheduledStartTime?: DateString\n    }\n}\n\nexport function isVideoAPIResponse(arg: any): arg is VideoAPIResponse {\n    return typeof arg == 'object' && arg.kind == 'youtube#videoListResponse'\n}\n","module.exports = require(\"https\");","export const youtube = {\n    search: 'https://www.googleapis.com/youtube/v3/search',\n    activities: 'https://www.googleapis.com/youtube/v3/activities',\n    videos: 'https://www.googleapis.com/youtube/v3/videos'\n}\n\nexport const self = {\n    videos: '/api/videos'\n}\n","export interface URLQuery {\n    [ key: string ]: string|number|undefined\n}\n\nexport function buildUrlQuery(url: string, query: URLQuery) {\n    const queryString = Object.keys(query).map(key => {\n        const value = query[key]\n        if (typeof value == 'undefined') return\n        return encodeURIComponent(key) + '=' + encodeURIComponent(value)\n    }).filter(it =>\n        typeof it != 'undefined'\n    ).join('&')\n    return url + '?' + queryString\n}\n","import { Thumbnails } from './Thumbnails'\nimport { DateString } from '../../util/DateString'\n\nexport interface SearchAPIOptions {\n    part: Array<'id'|'snippet'>\n    channelId?: string\n    eventType?: 'completed'|'live'|'upcoming'\n    maxResults?: number\n    order?: 'date'|'rating'|'relevance'\n    type?: 'video'\n    key?: string\n}\n\nexport interface SearchAPIResponse {\n    kind: 'youtube#searchListResponse'\n    etag: string\n    nextPageToken: string\n    prevPageToken: string\n    pageInfo: {\n        totalResults: number\n        resultsPerPage: number\n    }\n    items: SearchResult[]\n}\n\nexport function isSearchAPIResponse(arg: any): arg is SearchAPIResponse {\n    return typeof arg == 'object' && arg.kind == 'youtube#searchListResponse'\n}\n\nexport interface SearchResult {\n    kind: 'youtube#searchResult'\n    etag: string\n    id?: {\n        kind: string\n        videoId?: string\n    }\n    snippet?: {\n        publishedAt: DateString\n        channelId: string\n        title: string\n        description: string\n        thumbnails: Thumbnails\n    }\n    channelTitle: string\n}\n","import { Db, Collection } from 'mongodb'\nimport { Video } from '../API/YouTubeApiOptions/VideosAPIOptions'\nimport { getVideoTime } from '../util/videoTime'\n\ninterface CacheMeta {\n    lastUpdated: number,\n    lastFetch?: number\n}\n\ninterface VideoCache {\n    _id: Video['id'],\n    time: number,\n    item: Video,\n    update: number\n}\n\nexport async function cacheResponse(db: Db, videos: Video[], lastFetch?: number) {\n    const metadataCollection: Collection<CacheMeta> = db.collection('metadata')\n\n    const metaUpdate = lastFetch ? {\n        lastUpdated: new Date().getTime(),\n        lastFetch\n    } : {\n        lastUpdated: new Date().getTime()\n    }\n\n    await metadataCollection.updateOne({}, {\n        '$set': metaUpdate\n    }, {\n        upsert: true\n    })\n\n    const videosCollection: Collection<VideoCache> = db.collection('videos')\n    await Promise.all(videos.map(video => videosCollection.updateOne({\n        _id: video.id\n    }, {\n        '$set': {\n            _id: video.id,\n            time: getVideoTime(video).getTime(),\n            item: video,\n            update: Date.now()\n        }\n    }, {\n        upsert: true\n    })))\n}\n\nexport async function getCached(db: Db, limit: number = 50): Promise<{\n    lastUpdated: number,\n    lastFetch: number,\n    videos: Array<{ item: Video, fetched: number }>\n}> {\n    const metadataCollection: Collection<CacheMeta> = db.collection('metadata')\n    const videosCollection: Collection<VideoCache> = db.collection('videos')\n\n    const cacheMetadata = await metadataCollection.findOne({})\n    const videoCaches = await videosCollection.find()\n        .sort('time', -1)\n        .limit(limit)\n        .toArray()\n\n    const videos = videoCaches.map(it => ({ item: it.item, fetched: it.update }))\n    const lastUpdated = cacheMetadata?.lastUpdated ?? 0\n    const lastFetch = cacheMetadata?.lastFetch ?? 0\n\n    return { lastUpdated, lastFetch, videos }\n}\n","import { Video } from '../API/YouTubeApiOptions/VideosAPIOptions'\nimport { asDate } from './DateString'\n\nexport function getVideoTime(video: Video): Date {\n    if (video.liveStreamingDetails?.actualEndTime) {\n        return asDate(video.liveStreamingDetails.actualEndTime)\n    }\n    if (video.liveStreamingDetails?.scheduledStartTime) {\n        return asDate(video.liveStreamingDetails.scheduledStartTime)\n    } else {\n        return asDate(video.snippet?.publishedAt!!)\n    }\n}\n","export type DateString = string\n\nexport function asDate(dateString: DateString): Date {\n    return new Date(dateString)\n}\n","import { dotenv } from './dotenv'\nimport { fetch } from './fetch'\nimport { channels } from '../config/channels'\n\nexport async function requestSubscription(): Promise<boolean> {\n    const bodyObjs = Object.entries(channels).map(it => it[1]).map(channelId => ({\n        'hub.callback': `https://voms-timeline.comame.xyz/sub/hook?verify_token=${dotenv.WEBSUB_VERIFY_TOKEN}`,\n        'hub.verify': 'sync',\n        'hub.mode': 'subscribe',\n        'hub.secret': dotenv.WEBSUB_HUB_SECRET,\n        'hub.topic': `https://www.youtube.com/xml/feeds/videos.xml?channel_id=${channelId}`\n    }))\n    const bodyEncodeds = bodyObjs.map(obj => {\n        return Object.entries(obj).map(([ key, value ]) => {\n            return key + '=' + encodeURIComponent(value)\n        }).join('&')\n    })\n\n    const requestPromises = bodyEncodeds.map(body => fetch('https://pubsubhubbub.appspot.com/subscribe', {\n        method: 'POST',\n        body,\n        headers: {\n            'content-type': 'application/x-www-form-urlencoded',\n            'content-length': '' + body.length,\n            'user-agent': 'comame<dev@comame.xyz>'\n        }\n    }))\n\n    const responses = await Promise.all(requestPromises)\n    return responses.every(it => it.ok)\n}\n"],"sourceRoot":""}